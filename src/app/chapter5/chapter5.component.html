<div class="min-h-screen bg-gradient-to-br from-blue-50 to-green-100">
  <!-- Header -->
  <header class="bg-white shadow-lg border-b border-gray-200">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center py-4">
        <div class="flex items-center">
          <button
            (click)="backToDashboard()"
            class="mr-4 p-2 text-gray-600 hover:text-gray-900 transition-colors"
          >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
            </svg>
          </button>
          <div>
            <h1 class="text-2xl font-bold text-gray-900">🔄 Chapter 3: Introduction to Modern Symmetric-key Ciphers</h1>
            <p class="text-sm text-gray-600">Building Blocks and Principles</p>
          </div>
        </div>
        <div class="text-sm text-gray-600">
          Section {{ currentSection }} of {{ totalSections }}
        </div>
      </div>
    </div>
  </header>

  <!-- Progress Bar -->
  <div class="bg-white border-b">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="py-2">
        <div class="w-full bg-gray-200 rounded-full h-2">
          <div
            class="bg-green-600 h-2 rounded-full transition-all duration-300"
            [style.width.%]="(currentSection / totalSections) * 100"
          ></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Content -->
  <main class="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
    <div class="bg-white rounded-xl shadow-lg overflow-hidden">

      <!-- Section 1: Perfect vs. Computational Security -->
      <div *ngIf="currentSection === 1" class="p-8">
        <h2 class="text-3xl font-bold text-gray-900 mb-6">Perfect (Information-Theoretic) vs. Computational Security</h2>

        <div class="bg-blue-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700 text-lg leading-relaxed">
            In an ideal, information-theoretic model, a cipher is perfectly secure if its ciphertexts reveal no information about the plaintext, even to an adversary with unlimited computing power. This notion—also called semantic security or unconditional security—requires a key space at least as large as the plaintext space, as in the one-time pad.
          </p>
        </div>

        <div class="bg-green-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700 text-lg leading-relaxed">
            Because perfect secrecy is impractical for long messages, we adopt computational security: the guarantee that no feasible algorithm can recover the key within realistic resource limits. For instance, a 128-bit key would take on the order of 10^18 years to brute force with today's fastest supercomputers.
          </p>
        </div>

        <div class="grid md:grid-cols-2 gap-6">
          <div class="bg-gray-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Perfect Security</h3>
            <ul class="space-y-2 text-gray-700">
              <li class="flex items-start">
                <span class="text-blue-600 mr-2">•</span>
                <span>Requires key length ≥ message length</span>
              </li>
              <li class="flex items-start">
                <span class="text-blue-600 mr-2">•</span>
                <span>One-time pad is the canonical example</span>
              </li>
              <li class="flex items-start">
                <span class="text-blue-600 mr-2">•</span>
                <span>Secure against unlimited computational power</span>
              </li>
            </ul>
          </div>

          <div class="bg-gray-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Computational Security</h3>
            <ul class="space-y-2 text-gray-700">
              <li class="flex items-start">
                <span class="text-green-600 mr-2">•</span>
                <span>Fixed key length (e.g., 128, 256 bits)</span>
              </li>
              <li class="flex items-start">
                <span class="text-green-600 mr-2">•</span>
                <span>Security based on computational difficulty</span>
              </li>
              <li class="flex items-start">
                <span class="text-green-600 mr-2">•</span>
                <span>Practical for real-world applications</span>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Section 2: Evolution to Modern Ciphers -->
      <div *ngIf="currentSection === 2" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">From Substitution/Transposition to Substitution-Permutation Networks</h2>

        <p class="text-gray-700 mb-6">
          Classical ciphers used either substitution (e.g. Caesar cipher) or transposition (reordering) alone. Modern block ciphers combine both in repeated rounds—called substitution-permutation networks—to achieve strong confusion and diffusion.
        </p>

        <div class="grid md:grid-cols-2 gap-6 mb-6">
          <div class="bg-blue-50 rounded-lg p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-3">Substitution</h3>
            <p class="text-gray-700">
              Introduces confusion by creating complex key-ciphertext relationships.
            </p>
            <div class="mt-4 bg-white p-4 rounded border">
              <p class="text-sm text-gray-600">Example: Caesar Cipher</p>
              <div class="font-mono mt-2">
                <div>A → D</div>
                <div>B → E</div>
                <div>C → F</div>
              </div>
            </div>
          </div>

          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-3">Permutation (Transposition)</h3>
            <p class="text-gray-700">
              Spreads (diffuses) each plaintext bit across many ciphertext bits.
            </p>
            <div class="mt-4 bg-white p-4 rounded border">
              <p class="text-sm text-gray-600">Example: Column Transposition</p>
              <div class="font-mono mt-2">
                <div>HELLO → HLOEL</div>
                <div>(reordering letters)</div>
              </div>
            </div>
          </div>
        </div>

        <div class="bg-yellow-50 rounded-lg p-6">
          <h3 class="text-xl font-semibold text-gray-900 mb-3">Modern Approach: Substitution-Permutation Networks</h3>
          <div class="flex flex-col md:flex-row gap-4 items-center">
            <div class="flex-1">
              <p class="text-gray-700 mb-4">
                Modern ciphers combine substitution and permutation in multiple rounds to achieve both confusion and diffusion.
              </p>
              <button
                (click)="toggleSBoxAnimation()"
                class="bg-yellow-600 text-white px-4 py-2 rounded-md hover:bg-yellow-700 transition-colors"
              >
                {{ showSBoxAnimation ? 'Hide' : 'Show' }} SPN Animation
              </button>
            </div>
            <div *ngIf="showSBoxAnimation" class="flex-1 bg-white p-4 rounded border">
              <div class="text-center">
                <div class="font-mono mb-2">Plaintext Block</div>
                <div class="flex justify-center">
                  <div class="w-6 h-6 bg-blue-200 m-1 flex items-center justify-center">0</div>
                  <div class="w-6 h-6 bg-blue-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-blue-200 m-1 flex items-center justify-center">0</div>
                  <div class="w-6 h-6 bg-blue-200 m-1 flex items-center justify-center">1</div>
                </div>
                <div class="my-2">↓ Substitution (S-Box)</div>
                <div class="flex justify-center">
                  <div class="w-6 h-6 bg-green-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-green-200 m-1 flex items-center justify-center">0</div>
                  <div class="w-6 h-6 bg-green-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-green-200 m-1 flex items-center justify-center">1</div>
                </div>
                <div class="my-2">↓ Permutation (P-Box)</div>
                <div class="flex justify-center">
                  <div class="w-6 h-6 bg-purple-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-purple-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-purple-200 m-1 flex items-center justify-center">0</div>
                  <div class="w-6 h-6 bg-purple-200 m-1 flex items-center justify-center">1</div>
                </div>
                <div class="my-2">↓ Key Mixing (XOR)</div>
                <div class="flex justify-center">
                  <div class="w-6 h-6 bg-red-200 m-1 flex items-center justify-center">0</div>
                  <div class="w-6 h-6 bg-red-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-red-200 m-1 flex items-center justify-center">1</div>
                  <div class="w-6 h-6 bg-red-200 m-1 flex items-center justify-center">0</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Section 3: Core Building Blocks -->
      <div *ngIf="currentSection === 3" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Key Components of Block Ciphers</h2>

        <div class="space-y-6">
          <!-- P-Boxes -->
          <div class="bg-blue-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">P-Boxes (Permutation Boxes)</h3>
            <p class="text-gray-700 mb-4">
              Permutation boxes shuffle bits to spread patterns.
            </p>
            <div class="grid md:grid-cols-3 gap-4">
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Straight P-Box</h4>
                <p class="text-sm text-gray-600">Reorders bits one-to-one; invertible.</p>
              </div>
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Compression P-Box</h4>
                <p class="text-sm text-gray-600">n→m&lt;n; noninvertible.</p>
              </div>
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Expansion P-Box</h4>
                <p class="text-sm text-gray-600">n→m&gt;n; noninvertible.</p>
              </div>
            </div>
          </div>

          <!-- S-Boxes -->
          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">S-Boxes (Substitution Boxes)</h3>
            <p class="text-gray-700 mb-4">
              Miniature lookup tables implementing nonlinear bit mappings—essential for confusion. Invertibility requires equal input/output sizes, and S-box design is critical to withstand linear/differential attacks.
            </p>

            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Interactive S-Box Demo</h4>
              <div class="flex flex-col md:flex-row gap-4 items-center">
                <div class="flex-1">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Input (3 bits)</label>
                  <input
                    type="text"
                    [(ngModel)]="sBoxInput"
                    (ngModelChange)="lookupSBox()"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500"
                    maxlength="3"
                    placeholder="e.g., 101"
                  >
                </div>
                <div class="flex-1">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Output</label>
                  <div class="px-3 py-2 border border-gray-300 rounded-md bg-gray-50">
                    {{ sBoxOutput }}
                  </div>
                </div>
              </div>
              <div class="mt-4">
                <h5 class="text-sm font-medium text-gray-700 mb-2">S-Box Mapping</h5>
                <div class="overflow-x-auto">
                  <table class="min-w-full divide-y divide-gray-200">
                    <thead>
                      <tr>
                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Input</th>
                        <th *ngFor="let input of sBox[0]" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          {{ input }}
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="px-3 py-2 text-sm text-gray-500">Output</td>
                        <td *ngFor="let output of sBox[1]" class="px-3 py-2 text-sm text-gray-900">
                          {{ output }}
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

          <!-- XOR -->
          <div class="bg-yellow-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Exclusive-Or (XOR)</h3>
            <p class="text-gray-700 mb-4">
              A binary operation with closure, associativity, commutativity, identity, and self-inverse properties. XORing with a subkey scrambles data in an easily reversible way.
            </p>

            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Interactive XOR Demo</h4>
              <div class="grid md:grid-cols-3 gap-4 items-center">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Input 1</label>
                  <input
                    type="text"
                    [(ngModel)]="xorInput1"
                    (ngModelChange)="calculateXOR()"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                    placeholder="e.g., 10110101"
                  >
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Input 2</label>
                  <input
                    type="text"
                    [(ngModel)]="xorInput2"
                    (ngModelChange)="calculateXOR()"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                    placeholder="e.g., 11001010"
                  >
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Result</label>
                  <div class="px-3 py-2 border border-gray-300 rounded-md bg-gray-50 font-mono">
                    {{ xorResult }}
                  </div>
                </div>
              </div>
              <div class="mt-4 text-sm text-gray-600">
                <p>XOR Truth Table: 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0</p>
              </div>
            </div>
          </div>

          <!-- Bit Rotations & Swaps -->
          <div class="bg-purple-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Bit Rotations & Swaps</h3>
            <div class="grid md:grid-cols-3 gap-4">
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Circular Shift</h4>
                <p class="text-sm text-gray-600">Rotate all bits left or right by k.</p>
                <div class="mt-2 font-mono text-xs">
                  <div>10110 → 01101 (left 1)</div>
                  <div>10110 → 01011 (right 1)</div>
                </div>
              </div>
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Swap</h4>
                <p class="text-sm text-gray-600">Special case of rotation with k=n/2.</p>
                <div class="mt-2 font-mono text-xs">
                  <div>1011|0110 → 0110|1011</div>
                </div>
              </div>
              <div class="bg-white p-4 rounded border">
                <h4 class="font-semibold text-gray-900 mb-2">Split & Combine</h4>
                <p class="text-sm text-gray-600">Divide and reassemble halves for fine-grained diffusion.</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Section 4: Product & Iterated Ciphers -->
      <div *ngIf="currentSection === 4" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Building Security Through Rounds</h2>

        <div class="bg-blue-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700">
            Shannon's product cipher concept layers substitution and permutation to amplify confusion and diffusion. Modern block ciphers realize this via multiple rounds, each using a fresh subkey derived from the master key.
          </p>
        </div>

        <div class="grid md:grid-cols-2 gap-6">
          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Feistel Structure</h3>
            <p class="text-gray-700 mb-4">
              Split block in two, apply round function to one half, XOR with the other, then swap. Decryption uses the same operations in reverse key order.
            </p>
            <button
              (click)="toggleFeistelAnimation()"
              class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition-colors"
            >
              {{ showFeistelAnimation ? 'Hide' : 'Show' }} Feistel Animation
            </button>

            <div *ngIf="showFeistelAnimation" class="mt-4 bg-white p-4 rounded border">
              <div class="text-center">
                <div class="flex justify-center">
                  <div class="w-16 h-16 bg-blue-200 m-1 flex items-center justify-center">L₀</div>
                  <div class="w-16 h-16 bg-green-200 m-1 flex items-center justify-center">R₀</div>
                </div>
                <div class="my-2">↓ Round 1</div>
                <div class="flex justify-center">
                  <div class="w-16 h-16 bg-green-200 m-1 flex items-center justify-center">R₀</div>
                  <div class="w-16 h-16 bg-blue-300 m-1 flex items-center justify-center">L₀⊕F(R₀,K₁)</div>
                </div>
                <div class="my-2">↓ Round 2</div>
                <div class="flex justify-center">
                  <div class="w-16 h-16 bg-blue-300 m-1 flex items-center justify-center">L₀⊕F(R₀,K₁)</div>
                  <div class="w-16 h-16 bg-green-300 m-1 flex items-center justify-center">R₀⊕F(L₁,K₂)</div>
                </div>
              </div>
            </div>
          </div>

          <div class="bg-purple-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Non-Feistel Structure</h3>
            <p class="text-gray-700 mb-4">
              Apply invertible functions to the entire block, requiring distinct forward/reverse routines.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Examples</h4>
              <ul class="space-y-2 text-sm text-gray-600">
                <li>• AES (Rijndael)</li>
                <li>• IDEA</li>
                <li>• Serpent</li>
              </ul>
              <div class="mt-4 text-sm text-gray-600">
                <p>These ciphers typically use substitution-permutation networks (SPNs) that transform the entire block in each round.</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Section 5: Cryptanalysis of Block Ciphers -->
      <div *ngIf="currentSection === 5" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Differential & Linear Attacks</h2>

        <div class="grid md:grid-cols-2 gap-6">
          <div class="bg-red-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Differential Cryptanalysis</h3>
            <p class="text-gray-700 mb-4">
              A chosen-plaintext technique that examines how input differences propagate through S-boxes, exploiting statistical biases to recover subkey bits in surprisingly few queries.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Attack Process</h4>
              <ol class="list-decimal list-inside space-y-1 text-sm text-gray-600">
                <li>Choose plaintext pairs with specific differences</li>
                <li>Observe corresponding ciphertext differences</li>
                <li>Identify statistical patterns in the differences</li>
                <li>Deduce key bits from these patterns</li>
              </ol>
            </div>
          </div>

          <div class="bg-blue-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Linear Cryptanalysis</h3>
            <p class="text-gray-700 mb-4">
              A known-plaintext method that finds approximate linear equations relating plaintext, ciphertext, and key bits. By solving these equations across many message pairs, attackers can extract key bits from small biases.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Attack Process</h4>
              <ol class="list-decimal list-inside space-y-1 text-sm text-gray-600">
                <li>Find linear approximations of S-boxes</li>
                <li>Extend to linear approximations of the entire cipher</li>
                <li>Collect many plaintext-ciphertext pairs</li>
                <li>Statistically analyze to recover key bits</li>
              </ol>
            </div>
          </div>
        </div>

        <div class="mt-6 bg-yellow-50 border-l-4 border-yellow-400 p-4">
          <p class="text-gray-700">
            <strong>Defense:</strong> Modern ciphers use carefully designed S-boxes, sufficient rounds, and key schedules to resist these attacks. AES, for example, was specifically designed with resistance to differential and linear cryptanalysis in mind.
          </p>
        </div>
      </div>

      <!-- Section 6: Modes of Operation -->
      <div *ngIf="currentSection === 6" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Encrypting Arbitrary-Length Messages</h2>

        <div class="bg-blue-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700">
            Block ciphers natively handle fixed-size blocks. To secure longer messages, we chain blocks via modes of operation, each offering different trade-offs in parallelism, error handling, and pattern concealment.
          </p>
        </div>

        <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-gray-200">
            <thead>
              <tr>
                <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Mode</th>
                <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Key Feature</th>
                <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Pros</th>
                <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Error Propagation</th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
              <tr *ngFor="let mode of cipherModes">
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{{ mode.name }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ mode.keyFeature }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ mode.pros }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ mode.errorPropagation }}</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="mt-6 bg-green-50 border-l-4 border-green-400 p-4">
          <p class="text-gray-700">
            <strong>Note:</strong> Authenticated modes (e.g., GCM) combine encryption and integrity checks in one pass.
          </p>
        </div>

        <!-- ECB vs CBC Visualization -->
        <div class="mt-6 bg-purple-50 rounded-lg p-6">
          <h3 class="text-xl font-semibold text-gray-900 mb-3">ECB vs CBC Visualization</h3>
          <p class="text-gray-700 mb-4">
            See how ECB mode preserves patterns in the plaintext, while CBC mode obscures them.
          </p>

          <div class="grid md:grid-cols-3 gap-6">
            <div>
              <h4 class="font-semibold text-gray-900 mb-2">Original Pattern</h4>
              <div class="bg-white p-2 rounded border">
                <div class="grid grid-cols-8 gap-1">
                  <div *ngFor="let row of patternedImage">
                    <div *ngFor="let pixel of row"
                         class="w-4 h-4"
                         [class.bg-black]="pixel === 1"
                         [class.bg-white]="pixel === 0">
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div>
              <h4 class="font-semibold text-gray-900 mb-2">ECB Mode</h4>
              <div class="bg-white p-2 rounded border">
                <div class="grid grid-cols-8 gap-1">
                  <div *ngFor="let row of ecbEncryptedImage">
                    <div *ngFor="let pixel of row"
                         class="w-4 h-4"
                         [class.bg-black]="pixel === 1"
                         [class.bg-white]="pixel === 0">
                    </div>
                  </div>
                </div>
              </div>
              <p class="mt-2 text-sm text-gray-600">Pattern still visible!</p>
            </div>

            <div>
              <h4 class="font-semibold text-gray-900 mb-2">CBC Mode</h4>
              <div class="bg-white p-2 rounded border">
                <div class="grid grid-cols-8 gap-1">
                  <div *ngFor="let row of cbcEncryptedImage">
                    <div *ngFor="let pixel of row"
                         class="w-4 h-4"
                         [class.bg-black]="pixel === 1"
                         [class.bg-white]="pixel === 0">
                    </div>
                  </div>
                </div>
              </div>
              <p class="mt-2 text-sm text-gray-600">Pattern obscured!</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Section 7: Stream Cipher Basics -->
      <div *ngIf="currentSection === 7" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">From One-Time Pads to LFSRs</h2>

        <div class="bg-blue-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700">
            Stream ciphers encrypt plaintext one bit/byte at a time with a pseudorandom keystream. When truly random and single-use, they achieve perfect secrecy (one-time pad). In practice, keystream generators (LFSRs, nonlinear filters) replace random pads.
          </p>
        </div>

        <div class="grid md:grid-cols-2 gap-6">
          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Synchronous Stream Ciphers</h3>
            <p class="text-gray-700 mb-4">
              Keystream independent of message. Fast and simple, but reuse of the same keystream (two-time pad) is catastrophic.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Operation</h4>
              <div class="font-mono text-sm">
                <div>Key → PRNG → Keystream</div>
                <div>Plaintext ⊕ Keystream = Ciphertext</div>
              </div>
              <div class="mt-4 text-sm text-gray-600">
                <p><strong>Examples:</strong> RC4, ChaCha20</p>
              </div>
            </div>
          </div>

          <div class="bg-yellow-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Self-Synchronizing Stream Ciphers</h3>
            <p class="text-gray-700 mb-4">
              Keystream depends on previous ciphertext or plaintext bits, automatically resynchronizing after data loss.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Operation</h4>
              <div class="font-mono text-sm">
                <div>Key + Previous Ciphertext → PRNG → Keystream</div>
                <div>Plaintext ⊕ Keystream = Ciphertext</div>
              </div>
              <div class="mt-4 text-sm text-gray-600">
                <p><strong>Examples:</strong> CFB mode of block ciphers</p>
              </div>
            </div>
          </div>
        </div>

        <div class="mt-6 bg-red-50 border-l-4 border-red-400 p-4">
          <p class="text-gray-700">
            <strong>Warning:</strong> Never reuse a stream cipher key-IV pair! Doing so allows attackers to XOR ciphertexts together, canceling the keystream and revealing plaintext relationships.
          </p>
        </div>
      </div>

      <!-- Section 8: Case Studies & Trends -->
      <div *ngIf="currentSection === 8" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">From DES to AES and Beyond</h2>

        <div class="space-y-6">
          <div *ngFor="let cipher of cipherCases" class="bg-blue-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">{{ cipher.name }}</h3>
            <div class="grid md:grid-cols-3 gap-4 mb-4">
              <div class="bg-white p-3 rounded border">
                <h4 class="text-sm font-medium text-gray-700">Block Size</h4>
                <p class="font-mono">{{ cipher.blockSize }}</p>
              </div>
              <div class="bg-white p-3 rounded border">
                <h4 class="text-sm font-medium text-gray-700">Key Size</h4>
                <p class="font-mono">{{ cipher.keySize }}</p>
              </div>
              <div class="bg-white p-3 rounded border">
                <h4 class="text-sm font-medium text-gray-700">Rounds</h4>
                <p class="font-mono">{{ cipher.rounds }}</p>
              </div>
            </div>
            <p class="text-gray-700">{{ cipher.description }}</p>
          </div>

          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Lightweight & High-Performance Ciphers</h3>
            <p class="text-gray-700 mb-4">
              For IoT and embedded systems, designers created ciphers like Blowfish, RC5, and Speck with tunable parameters, balancing security, speed, and footprint.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Key Considerations</h4>
              <ul class="space-y-2 text-sm text-gray-600">
                <li>• Memory footprint (RAM/ROM usage)</li>
                <li>• Energy efficiency (battery life)</li>
                <li>• Processing speed (latency)</li>
                <li>• Security margin vs. performance</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Section 9: Key Schedules & Performance -->
      <div *ngIf="currentSection === 9" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Deriving Round Keys</h2>

        <div class="bg-blue-50 rounded-lg p-6 mb-6">
          <p class="text-gray-700">
            A robust key schedule generates distinct, uncorrelated subkeys for each round, satisfying avalanche criteria and thwarting related-key attacks. Some ciphers even use the master key to permute S-boxes or determine shift amounts.
          </p>
        </div>

        <div class="bg-white rounded-lg border p-6 mb-6">
          <h3 class="text-lg font-semibold text-gray-900 mb-4">Key Schedule Design Principles</h3>
          <ul class="space-y-3 text-gray-700">
            <li class="flex items-start">
              <span class="text-blue-600 mr-2">•</span>
              <span><strong>Variable Key Length:</strong> Longer keys resist exhaustive search but add setup overhead.</span>
            </li>
            <li class="flex items-start">
              <span class="text-blue-600 mr-2">•</span>
              <span><strong>Mixed Operations:</strong> Rotations, S-box lookups, and arithmetic in the schedule add nonlinearity.</span>
            </li>
            <li class="flex items-start">
              <span class="text-blue-600 mr-2">•</span>
              <span><strong>Key-Dependent Components:</strong> Custom S-boxes or P-boxes per key further complicate attacks.</span>
            </li>
          </ul>
        </div>

        <div class="grid md:grid-cols-2 gap-6">
          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-3">AES Key Schedule</h3>
            <p class="text-gray-700 mb-4">
              Uses a combination of rotations, S-box substitutions, and XOR operations to derive round keys.
            </p>
            <div class="bg-white p-3 rounded border text-sm text-gray-600">
              <p>For AES-128, the 128-bit master key expands to 11 round keys (1408 bits total).</p>
            </div>
          </div>

          <div class="bg-yellow-50 rounded-lg p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-3">Performance Considerations</h3>
            <ul class="space-y-2 text-sm text-gray-600">
              <li>• Key setup time vs. encryption time</li>
              <li>• Memory requirements for storing round keys</li>
              <li>• Hardware vs. software optimization</li>
              <li>• Cache-timing attack resistance</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Section 10: Active Learning & Exercises -->
      <div *ngIf="currentSection === 10" class="p-8">
        <h2 class="text-2xl font-bold text-gray-900 mb-6">Active Learning & Exercises</h2>

        <div class="space-y-6">
          <div class="bg-blue-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Task 1: Build a Mini Feistel Network</h3>
            <p class="text-gray-700 mb-4">
              Implement a 4-round Feistel cipher in Python using XOR-based round functions; verify encryption/decryption correctness.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Python Skeleton</h4>
              <pre class="bg-gray-900 text-green-400 p-4 rounded text-sm overflow-x-auto">
def round_function(right_half, subkey):
    # Implement a simple round function
    # (e.g., XOR with subkey)
    pass

def feistel_encrypt(plaintext, subkeys):
    # Split plaintext into left and right halves
    # Apply 4 rounds of Feistel structure
    pass

def feistel_decrypt(ciphertext, subkeys):
    # Decrypt using the same structure but reversed subkeys
    pass
              </pre>
            </div>
          </div>

          <div class="bg-green-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Task 2: S-Box Differential Table</h3>
            <p class="text-gray-700 mb-4">
              Given a small 3×3 S-box, compute its differential distribution table and identify the highest-probability input/output difference.
            </p>
            <div class="bg-white p-4 rounded border">
              <h4 class="font-semibold text-gray-900 mb-2">Steps</h4>
              <ol class="list-decimal list-inside space-y-1 text-sm text-gray-600">
                <li>For each input difference Δx</li>
                <li>For each possible input x</li>
                <li>Compute S(x) and S(x⊕Δx)</li>
                <li>Calculate output difference Δy = S(x)⊕S(x⊕Δx)</li>
                <li>Increment count for (Δx, Δy) pair</li>
              </ol>
            </div>
          </div>

          <div class="bg-yellow-50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-gray-900 mb-3">Task 3: Mode Comparison Demo</h3>
            <p class="text-gray-700 mb-4">
              Encrypt a patterned image or text in ECB vs. CBC mode; observe how CBC conceals repeated patterns that ECB leaks.
            </p>
            <div class="flex items-center justify-center gap-4 mt-4">
              <button
                (click)="selectedMode = 'ecb'"
                class="px-4 py-2 rounded-md text-sm font-medium transition-colors"
                [class.bg-yellow-600]="selectedMode === 'ecb'"
                [class.text-white]="selectedMode === 'ecb'"
                [class.bg-gray-200]="selectedMode !== 'ecb'"
                [class.text-gray-700]="selectedMode !== 'ecb'"
              >
                ECB Mode
              </button>
              <button
                (click)="selectedMode = 'cbc'"
                class="px-4 py-2 rounded-md text-sm font-medium transition-colors"
                [class.bg-yellow-600]="selectedMode === 'cbc'"
                [class.text-white]="selectedMode === 'cbc'"
                [class.bg-gray-200]="selectedMode !== 'cbc'"
                [class.text-gray-700]="selectedMode !== 'cbc'"
              >
                CBC Mode
              </button>
            </div>
            <div class="grid md:grid-cols-2 gap-6 mt-4">
              <div>
                <h4 class="font-semibold text-gray-900 mb-2">Original Pattern</h4>
                <div class="bg-white p-2 rounded border">
                  <div class="grid grid-cols-8 gap-1">
                    <div *ngFor="let row of patternedImage">
                      <div *ngFor="let pixel of row"
                           class="w-6 h-6"
                           [class.bg-black]="pixel === 1"
                           [class.bg-white]="pixel === 0">
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div>
                <h4 class="font-semibold text-gray-900 mb-2">Encrypted ({{ selectedMode.toUpperCase() }} Mode)</h4>
                <div class="bg-white p-2 rounded border">
                  <div class="grid grid-cols-8 gap-1">
                    <div *ngFor="let row of selectedMode === 'ecb' ? ecbEncryptedImage : cbcEncryptedImage">
                      <div *ngFor="let pixel of row"
                           class="w-6 h-6"
                           [class.bg-black]="pixel === 1"
                           [class.bg-white]="pixel === 0">
                      </div>
                    </div>
                  </div>
                </div>
                <p *ngIf="selectedMode === 'ecb'" class="mt-2 text-sm text-red-600">
                  Notice how the pattern is still visible in ECB mode!
                </p>
                <p *ngIf="selectedMode === 'cbc'" class="mt-2 text-sm text-green-600">
                  CBC mode successfully hides the original pattern.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Navigation -->
      <div class="bg-gray-50 px-8 py-6 flex justify-between items-center">
        <button
          (click)="previousSection()"
          [disabled]="currentSection === 1"
          class="flex items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
          </svg>
          Previous
        </button>

        <div class="flex space-x-2">
          <button
            *ngFor="let section of [].constructor(totalSections); let i = index"
            (click)="goToSection(i + 1)"
            class="w-8 h-8 rounded-full text-sm font-medium transition-colors"
            [class.bg-green-600]="currentSection === i + 1"
            [class.text-white]="currentSection === i + 1"
            [class.bg-gray-200]="currentSection !== i + 1"
            [class.text-gray-700]="currentSection !== i + 1"
            [class.hover:bg-gray-300]="currentSection !== i + 1"
          >
            {{ i + 1 }}
          </button>
        </div>

        <button
          (click)="nextSection()"
          [disabled]="currentSection === totalSections"
          class="flex items-center px-4 py-2 text-sm font-medium text-white bg-green-600 border border-transparent rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Next
          <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
          </svg>
        </button>
      </div>
    </div>
  </main>
</div>

